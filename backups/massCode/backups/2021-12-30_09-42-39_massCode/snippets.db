{"name":"Управление репозиторием","folderId":"ov1CCDtKz","content":[{"label":"Fragment 1","language":"powershell","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1638120181673},"updatedAt":{"$$date":1639328018970},"folder":{"id":"ov1CCDtKz","name":"Git commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"0Ov4ceL41lVdu4TK"}
{"name":"Прочие команды","folderId":"MsSQGFOv5","content":[{"label":"Fragment 1","language":"powershell","value":"команда ; команда   # Осуществляет последовательное выполнение команд.\r\nкоманда && команда  # Осуществляет последовательное выполнение команд, если предыдущая была выполнена успешно.\r\nкоманда || команда  # Осуществляет последовательное выполнение команд, если предыдущая была не выполнена.\r\n\r\nfind                # Осуществляет поиск в файловой системе, файлах и папках.\r\n\r\npwd                 # Отображает текущий каталог. Сокращение от Print working directory.\r\n\r\nclear               # Очищает окно терминала от сообщений.\r\n\r\nhistory             # Отображает список команд, вводимых ранее."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1638102278978},"updatedAt":{"$$date":1638447911842},"_id":"7Hxz6DxHszApe8Oo","folder":{"id":"MsSQGFOv5","name":"Terminal commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Terminal commands","folderId":"MsSQGFOv5","content":[{"label":"Управления файловой структурой","language":"text","value":"ls\r\n  Выводит содержимое в директории. Сокращение от List. \r\n  Пример - ls\r\nls -l\r\n  Выводит содержимое в директории в виде списка. \r\n  Пример - ls -l\r\nls -a\r\n  Выводит содержимое в директории, в том числе скрытые файлы. \r\n  Пример - ls -a\r\n\r\ncd\r\n  Переходит с текущей директории на указанную. Сокращение от Change Directory.\r\n  Пример - cd имя_директории/\r\ncd ..\r\n  Переходит в директорию на уровень выше.\r\n  Пример - cd ..\r\ncd ~\r\n  Меняет директорию на root.\r\n  Пример - cd ~\r\ncd -\r\n  Возвращает к предыдущей директории.\r\n  Пример - cd -\r\n  \r\n\r\ncat\r\n  Команда двойного назначения. Показывает на экране что содержит файл. Также помещает несколько переданных подряд файлов в один. Сокращение от Concatenate.\r\n  Пример 1 - cat имя_файла.расширение\r\n  Пример 2 - cat имя_файла_1.расширение имя_файла_2.расширение\r\n  Пример 3 - cat имя_файла_1.расширение имя_файла_2.расширение > имя_файла_3.расширение\r\n\r\nmkdir\r\n  Создаёт новую директорию. Сокращение от Make Directory.\r\n  Пример - mkdir имя_директории\r\n\r\ntouch\r\n  Создаёт пустой файл.\r\n  Пример 1 - touch имя_файла.расширение\r\n>\r\n  Создаёт пустой файл.\r\n  Пример - > имя_директории\r\n\r\necho\r\n  Выводит строку.\r\n  Пример - echo Текст touch имя_файла.расширение\r\n\r\nrm\r\n  Удаляет файлы или директории. Сокращение от Remove.\r\n  Пример - rm имя_файла.расширение\r\nrm -r\r\n  Удаляет рекурсивно директорию.\r\n  Пример - rm -r имя_директории\r\n\r\ncp\r\n  Копирование файлов. Сокращение от Copy.\r\n  Пример - cp имя_файла.расширение новое_имя_файла.расширение\r\ncp -r\r\n  Копирование директорий.\r\n  Пример - cp -r имя_директории имя_директории"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1637858658047},"updatedAt":{"$$date":1638040421362},"_id":"8Dik0NLYjAIkuEt3","folder":{"id":"MsSQGFOv5","name":"Terminal commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Команды ssh-клиента","folderId":"MsSQGFOv5","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1638189141512},"updatedAt":{"$$date":1638189166392},"_id":"8upzUTOJTpjIVu2B","folder":{"id":"MsSQGFOv5","name":"Terminal commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Индексирование","folderId":"ov1CCDtKz","content":[{"label":"Fragment 1","language":"powershell","value":"git add .                          # Добавляет в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий.\r\ngit add имя_файла                  # Добавляет в индекс указанный изменненый, удаленный или новый файл.\r\ngit add -i                         # Запускает интерактивную оболочку для добавления в индекс только выбранных файлов.\r\n\r\ngit commit -m \"сообщение\"          # Коммитит проиндексированные изменения и добавляет сообщение.\r\ngit commit -c хеш_коммита          # Коммитит проиндексированные изменения, описание и информация об авторе берется из указанного коммита с редактированием.\r\ngit commit -С хеш_коммита          # Коммитит проиндексированные изменения, описание и информация об авторе берется из указанного коммита без редактирования.\r\ngit commit --amend -m \"сообщение\"  # Перемещает ветку на коммит назад, не обновляя рабочую директорию с индексом и на их основе создает новый коммит. Предыдущий коммит уходит из ветки. \r\n\r\ngit revert                         # Создает новый коммит, отменяющий изменения предыдущего коммита.\r\ngit revert хеш_коммита             # Создает новый коммит, отменяющий изменения указанного коммита.\r\n"}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1639324939019},"updatedAt":{"$$date":1639327952347},"_id":"EHdpsqpjuq2ZyCk8","folder":{"id":"ov1CCDtKz","name":"Git commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Команды запущенных процессов","folderId":"MsSQGFOv5","content":[{"label":"Fragment 1","language":"powershell","value":"ctrl + c  # Комбинация завершает выполнение любого процесса в терминале Linux.\r\nctrl + z  # Комбинация ставит любой запущенный в консоли процесс на паузу. Снова запустить его можно, введя %."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1638103114713},"updatedAt":{"$$date":1638422583269},"_id":"FPZSTYo7wYsWV7sD","folder":{"id":"MsSQGFOv5","name":"Terminal commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Управление логами","folderId":"ov1CCDtKz","content":[{"label":"Fragment 1","language":"powershell","value":"git log                                     # Показывает коммиты в текущей ветке.\r\ngit log -p                                  # Показывает коммиты и изменения в текущей ветке.\r\ngit log имя_ветки                           # Показывает коммиты в указанной ветке.\r\ngit log -p имя_ветки                        # Показывает коммиты и изменения в указанной ветке.\r\ngit log имя_файла                           # Показывает коммиты в указанном файле.\r\ngit log -p имя_файла                        # Показывает коммиты и изменения в в указанном файле.\r\ngit log -количество_коммитов                # Показывает указанное количество последних коммитов в текущей ветке.\r\ngit log -G искомое_слово                    # Показывает коммиты, где присутствует искомое слово в изменениях файлов.\r\ngit log -G искомое_слово -p                 # Показывает коммиты и изменения в них, где присутствует искомое слово в изменениях файла.\r\ngit log --grep искомое_слово                # Показывает коммиты, где присутствует искомое слово в описании коммита.\r\n\r\ngit reflog                                  # Показывает список коммитов, на которых были изменения или перемещался указатель.\r\ngit branch имя_ветки HEAD@{номер_рефллога}  # Перемещает указатель на указанный коммит и востанавливает ветку, если была удалена.\r\n\r\ngit show                                    # Показывает коммиты в текущей ветке и внесенные изменения.\r\ngit show хеш_коммита                        # Показывает коммит в указанном коммите или ветке и внесенные изменения.\r\n\r\ngit diff                                    # Сравнивает текущие рабочую директорию и индексом.\r\ngit diff хеш_коммита                        # Сравнивает текущую рабочую директорию и указанный коммит.\r\ngit diff хеш_коммита имя_файла              # Сравнивает текущую рабочую директорию и указанный коммит для указанного файла.\r\ngit diff имя_ветки имя_ветки                # Сравнивает коммиты в указанных ветках.\r\ngit diff хеш_коммита хеш_коммита            # Сравнивает коммиты в указанных коммитах.\r\ngit diff имя_ветки имя_ветки имя_файла      # Сравнивает коммиты в указанных ветках для указанных файлов.\r\ngit diff --cached                           # Сравнивает текущие индекс и коммит.\r\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1638120143442},"updatedAt":{"$$date":1639328823374},"_id":"FfJZX9kRHFMx1sli","folder":{"id":"ov1CCDtKz","name":"Git commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Git commands","folderId":"MsSQGFOv5","content":[{"label":"Fragment 1","language":"text","value":""}],"tags":[],"isFavorites":false,"isDeleted":true,"createdAt":{"$$date":1637862024853},"updatedAt":{"$$date":1637862032053},"_id":"GU8wvnqpJvoqLZ65","folder":{"id":"MsSQGFOv5","name":"Terminal/Console","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Управление настройками git'а","folderId":"ov1CCDtKz","content":[{"label":"Fragment 1","language":"powershell","value":"git config --list                                 # Просматривает настройки git\r\ngit config --list --local                         # Просматривает локальные настройки git\r\ngit config --list --global                        # Просматривает глобальные настройки git\r\n\r\ngit config --local user.email название_email      # Указывает в локальных настройках имя, которая будет в описании коммита.\r\ngit config --local user.email название_email      # Указывает в локальных настройках электроную почту, которая будет в описании коммита.\r\n\r\ngit config --global user.name имя_пользователя    # Указывает в глобальных настройках имя, которым будут подписаны коммиты.\r\ngit config --global user.email название_email     # Указывает в глобальных настройках электроную почту, которая будет в описании коммита.\r\ngit config --global core.editor путь_к_редактору  # Устанавливает редактор кода\r\ngit config --global alies.c имя_команды           # Создание alies. Своя команда, замена более длинной команде git. \r\n\r\ngit config --unset --local user.name              # Удаляет имя из локальных настроек git\r\ngit config --unset --local user.email             # Удаляет имя из локальных настроек git\r\ngit config --unset --global user.name             # Удаляет имя из глобальных настроек git\r\ngit config --unset --global user.email            # Удаляет имя из глобальных настроек git\r\n\r\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1638108963116},"updatedAt":{"$$date":1639293497603},"_id":"HUj3ALTIBxLvvJtX","folder":{"id":"ov1CCDtKz","name":"Git commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"docBlock","folderId":"bA_1WKs89","content":[{"label":"Описание","language":"php","value":"<?php\r\n\r\n// @author Steelmoorg                                       # Имя автора кода.\r\n// @category Zend                                           # Имя категории, в которую объединены несколько пакетов.\r\n// @deprecated 1.7                                          # Дескриптор указывает на то, что код устарел. В качестве значения дескриптора указывается версия, начиная с которой код считается устаревшим.\r\n// @example /path/example.php                               # Указывает путь к файлу, содержащему пример использования кода..\r\n// @final none                                              # Дескриптор отмечает методы или свойства, которые не могут быть перегружены в дочерних классах. Также может быть отмечен класс, который не должен быть наследован.\r\n// @global datatype                                         # Дескриптор для декларации глобальных переменных.\r\n// @ignore none                                             # Сообщает phpDocumentor’у, что данный код не следует включать в лист документации.\r\n// @internal комментарий                                    # Значение дискриптора не будет добавлено в файлы документации.\r\n// @license http://www.example.com/License.txt GPL License  # Добавляет ссылку на лицензию, под которой распространяется код.\r\n// @link http://www.example.com Текст ссылки                # Дает возможность добавить ссылку к любому документируемому коду.\r\n// @method returntype описание                              # Используется для описания магического метода __call().\r\n// @name $globalvariablename                                # Дает возможность сослаться на краткое имя глобальной переменной, объявленной с помощью @global.\r\n// @package Zend_Pdf                                        # Указание имени пакета, в который входит данный программный код (файл).\r\n// @param datatype $paramname описание                      # Дескриптор описывает входные параметры для функций и методов классов.\r\n// @return datatype описание                                # Используется для описания данных, возвращаемых функцией или методом класса.\r\n// @see …                                                   # Дескриптор предлагает обратиться к другому, уже существующему докблоку.\r\n// @since v 0.7                                             # Указывает на версию пакета/класса, с которой комментируемый элемент стал доступен.\r\n// @subpackage Name                                         # Используется для объединения нескольких пакетов в один раздел документации.\r\n// @todo Something                                          # Можно описать будущие возможные изменения кода.\r\n// @throws MyException                                      # Указывает тип исключения, который может быть возвращен участком кода.\r\n// @var datatype                                            # Указывает тип свойства класса.\r\n// @version Version 1.1                                     # Текущая версия реализации документируемого кода."},{"label":"Сниппет","language":"php","value":"<?php\r\nСнипет - bxpdoc (Шапка дока)\r\n /**\r\n  * ToDo: Указать что нужно позже сделать сделать \r\n  * Описание класса/метода\r\n  * @author Bloodmoorg\r\n  * @param string $value Описание входных параметров функции\r\n  * @return void\r\n  */"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1637166839767},"updatedAt":{"$$date":1639575721840},"_id":"ORPuRMypJw5COIj7","folder":{"id":"bA_1WKs89","name":"PHP","open":false,"defaultLanguage":"text","children":[]},"tagsPopulated":[]}
{"name":"Работа с HL-блоками","folderId":"-2irHeXbe","content":[{"label":"Сниппеты","language":"php","value":"<?php\r\nСниппет - bxbhladd (Добавление записи в HL-блок)\r\n// use Bitrix\\Main\\Loader::includeModule('highloadblock'); \r\n// use Bitrix\\Highloadblock; \r\n// use Bitrix\\Main\\Entity;\r\n\r\n// Если известен ID highloadblock к которому будем делать запросы, то указываем его в $hlbl.\r\n$hlbl = 1;\r\n$hlblock = Highloadblock\\HighloadBlockTable::getById($hlbl)->fetch();\r\n\r\n// Если известна Название сущности highloadblock к которому будем делать запросы, то указываем его в $hlblock.\r\n$hlblock = 'название сущности';\r\n\r\n$entity = Highloadblock\\HighloadBlockTable::compileEntity($hlblock); \r\n$entity_data_class = $entity->getDataClass(); \r\n\r\n// Массив полей для добавления записи с порядковым ID\r\n$data = \r\n[\r\n  \"UF_NAME\" => $value,\r\n];\r\n  \r\n$result = $entity_data_class::add($data);\r\n\r\n\r\n\r\n\r\nСниппет - bxhblupdate (Обновление записи в HL-блоке)\r\n// use Bitrix\\Main\\Loader::includeModule('highloadblock'); \r\n// use Bitrix\\Highloadblock; \r\n// use Bitrix\\Main\\Entity;\r\n\r\n// Если известен ID highloadblock к которому будем делать запросы, то указываем его в $hlbl.\r\n$hlbl = 1;\r\n$hlblock = Highloadblock\\HighloadBlockTable::getById($hlbl)->fetch();\r\n\r\n// Если известна Название сущности highloadblock к которому будем делать запросы, то указываем его в $hlblock.\r\n$hlblock = 'название сущности';\r\n\r\n$entity = Highloadblock\\HighloadBlockTable::compileEntity($hlblock); \r\n$entity_data_class = $entity->getDataClass(); \r\n\r\n// Массив полей для обновления записи\r\n$data = \r\n[\r\n  \"UF_NAME_1\" => $value,\r\n  \"UF_NAME_2\" => $value,\r\n  \"UF_NAME_3\" => $value,\r\n];\r\n\r\n// ID записи\r\n$idForUpdate = 10;\r\n\r\n$result = $entity_data_class::update($idForUpdate, $data);\r\n\r\n\r\n\r\n\r\nСниппет - bxbhldelete (Удаление записи в HL-блоке)\r\n// use Bitrix\\Main\\Loader::includeModule('highloadblock'); \r\n// use Bitrix\\Highloadblock; \r\n// use Bitrix\\Main\\Entity;\r\n\r\n// Если известен ID highloadblock к которому будем делать запросы, то указываем его в $hlbl.\r\n$hlbl = 1;\r\n$hlblock = Highloadblock\\HighloadBlockTable::getById($hlbl)->fetch();\r\n\r\n// Если известна Название сущности highloadblock к которому будем делать запросы, то указываем его в $hlblock.\r\n$hlblock = 'название сущности';\r\n\r\n$entity = Highloadblock\\HighloadBlockTable::compileEntity($hlblock); \r\n$entity_data_class = $entity->getDataClass(); \r\n\r\n// ID записи\r\n$idForDelete = 10;\r\n\r\n$entity_data_class::Delete($idForDelete);"},{"label":"Получение записи из HL-блок","language":"php","value":"<?php\r\nuse Bitrix\\Main\\Loader::includeModule('highloadblock'); \r\nuse Bitrix\\Highloadblock; \r\nuse Bitrix\\Main\\Entity;\r\n\r\n// Если известен ID highloadblock к которому будем делать запросы, то указываем его в $hlbl.\r\n$hlbl = 1;\r\n$hlblock = Highloadblock\\HighloadBlockTable::getById($hlbl)->fetch();\r\n\r\n// Если известна Название сущности highloadblock к которому будем делать запросы, то указываем его в $hlblock.\r\n$hlblock = 'название сущности';\r\n\r\n$entity = Highloadblock\\HighloadBlockTable::compileEntity($hlblock); \r\n$entity_data_class = $entity->getDataClass(); \r\n\r\n// Достаем необходимые поля\r\n$res = $entity_data_class::getList(['filter'=>[\"UF_NAME_1\", \"UF_NAME_2\"]]);\r\nwhile ($item = $res->fetch())\r\n{\r\n    $name_1 = $item[\"UF_NAME_1\"];\r\n    $name_2 = $item[\"UF_NAME_2\"];\r\n}"},{"label":"Добавление записи в HL-блок","language":"php","value":"<?php\r\nuse Bitrix\\Main\\Loader::includeModule('highloadblock'); \r\nuse Bitrix\\Highloadblock; \r\nuse Bitrix\\Main\\Entity;\r\n\r\n// Если известен ID highloadblock к которому будем делать запросы, то указываем его в $hlbl.\r\n$hlbl = 1;\r\n$hlblock = Highloadblock\\HighloadBlockTable::getById($hlbl)->fetch();\r\n\r\n// Если известна Название сущности highloadblock к которому будем делать запросы, то указываем его в $hlblock.\r\n$hlblock = 'название сущности';\r\n\r\n$entity = Highloadblock\\HighloadBlockTable::compileEntity($hlblock); \r\n$entity_data_class = $entity->getDataClass(); \r\n\r\n// Массив полей для добавления записи с порядковым ID\r\n$data = \r\n[\r\n  \"UF_NAME_1\" => $value,\r\n  \"UF_NAME_2\" => $value,\r\n  \"UF_NAME_3\" => $value,\r\n];\r\n  \r\n$result = $entity_data_class::add($data);"},{"label":"Обновление записи в HL-блок","language":"php","value":"<?php\r\nuse Bitrix\\Main\\Loader::includeModule('highloadblock'); \r\nuse Bitrix\\Highloadblock; \r\nuse Bitrix\\Main\\Entity;\r\n\r\n// Если известен ID highloadblock к которому будем делать запросы, то указываем его в $hlbl.\r\n$hlbl = 1;\r\n$hlblock = Highloadblock\\HighloadBlockTable::getById($hlbl)->fetch();\r\n\r\n// Если известна Название сущности highloadblock к которому будем делать запросы, то указываем его в $hlblock.\r\n$hlblock = 'название сущности';\r\n\r\n$entity = Highloadblock\\HighloadBlockTable::compileEntity($hlblock); \r\n$entity_data_class = $entity->getDataClass(); \r\n\r\n// Массив полей для обновления записи\r\n$data = \r\n[\r\n  \"UF_NAME_1\" => $value,\r\n  \"UF_NAME_2\" => $value,\r\n  \"UF_NAME_3\" => $value,\r\n];\r\n\r\n// ID записи\r\n$idForUpdate = 10;\r\n\r\n$result = $entity_data_class::update($idForUpdate, $data);"},{"label":" Удаление записи в HL-блок","language":"php","value":"<?php\r\nuse Bitrix\\Main\\Loader::includeModule('highloadblock'); \r\nuse Bitrix\\Highloadblock; \r\nuse Bitrix\\Main\\Entity;\r\n\r\n// Если известен ID highloadblock к которому будем делать запросы, то указываем его в $hlbl.\r\n$hlbl = 1;\r\n$hlblock = Highloadblock\\HighloadBlockTable::getById($hlbl)->fetch();\r\n\r\n// Если известна Название сущности highloadblock к которому будем делать запросы, то указываем его в $hlblock.\r\n$hlblock = 'название сущности';\r\n\r\n$entity = Highloadblock\\HighloadBlockTable::compileEntity($hlblock); \r\n$entity_data_class = $entity->getDataClass(); \r\n\r\n// ID записи\r\n$idForDelete = 10;\r\n\r\n$entity_data_class::Delete($idForDelete);"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1638365847756},"updatedAt":{"$$date":1640595716150},"_id":"RxOCzkX5b02tFEUe","folder":{"id":"-2irHeXbe","name":"Bitrix","open":false,"defaultLanguage":"text","children":[]},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640699101261},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Файловая система","folderId":"MsSQGFOv5","content":[{"label":"Управления файловой структурой","language":"powershell","value":"ls                                         # Выводит содержимое в директории. Сокращение от List. \r\nls -l                                      # Выводит содержимое в директории в виде списка.\r\nls -a                                      # Выводит содержимое в директории, в том числе скрытые файлы.\r\n\r\ncd имя_директории/                         # Переходит с текущей директории на указанную. Сокращение от Change Directory.\r\ncd ..                                      # Переходит в директорию на уровень выше.\r\ncd ~                                       # Переходит в директорию root.\r\ncd -                                       # Возвращает к предыдущей директории.\r\n  \r\ncat имя_файла                              # Выводит содержимое файла. Сокращение от Concatenate.\r\ncat -n имя_файла                           # Выводит содержимое файла с нумерацией строк.\r\ncat имя_файла имя_файла                    # Конкантенация файлов и вывод содержимого.\r\n\r\nmkdir имя_директории                       # Создаёт новую директорию. Сокращение от Make Directory.\r\n\r\ntouch имя_файла                            # Создаёт файл.\r\n> имя_файла                                # Создаёт файл.\r\nnano имя_файла                             # Создает или открывает имеющийся файл в текстовом редакторе nano.\r\nvi имя_файла                               # Создает или открывает имеющийся файл в текстовом редакторе vim.\r\n\r\necho текст > имя_файла                     # Создает файл, добавляя в него текст.\r\necho текст >> имя_файла                    # Создает или редактирует имеющийся файл, добавляяя в него текст с новой строки.\r\n\r\ncp имя_файла новое_имя_файла               # Копирование файлов. Сокращение от Copy.\r\ncp -r имя_директории новое_имя_директории  # Копирование директорий.\r\n\r\nmv имя_файла новое_имя_файла               # Перемещение файлов. Сокращение от Move.\r\nmv -r имя_директории новое_имя_директории  # Перемещение директорий.\r\n\r\nrm имя_файла                               # Удаляет файлы или директории. Сокращение от Remove.\r\nrm -r имя_директории                       # Удаляет рекурсивно директорию.\r\n  \r\nln путь_к_файлу необязательное_имя_файла   # Создаёт программные ссылки на файлы. Сокращение от Link.\r\n\r\nzip имя_архива имя_файла                   # Архивирование и сжатие файлов посредством zip.\r\nzip -[0-9] имя_архива имя_файла            # Архивирование и сжатие файлов посредством zip, с указанием величины сжатия.\r\nzip -e имя_архива имя_файла                # Архивирование и сжатие файлов посредством zip, и создание пароля к архиву.\r\nunzip имя_архива                           # Распаковка архива.\r\nunzip -l имя_архива                        # Посмотреть что содержиться в архиве.\r\n\r\ngzip -c имя_файла                          # Сжатие файлов посредством gzip\r\ngzip -c -[0-9] имя_файла                   # Сжатие файлов посредством gzip, с указанием величины сжатия.\r\ngunzip -c имя_архива                       # Распаковка архива, сжатых с помощью gzip.\r\n\r\nfinde . -name \"*искомое_слово*\"            # Поиск файлов по имени или его части рекурсивно.\r\n\r\ngrep искомая_строка имя_файла              # Поиск и вывод тестовых фрагментов файла.\r\ngrep -i искомая_строка имя_файла           # Поиск и вывод тестовых фрагментов файла без учета регистра.\r\ngrep -w искомое_слово имя_файла            # Поиск и вывод  файлов с искомым словом.\r\ngrep -R искомая_строка имя_директории      # Поиск и вывод  файлов с искомым словом рекурсивно.\r\ngrep искомая_строка имя_директории         # Поиск фрагментов текстового файла в директории."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1638040447663},"updatedAt":{"$$date":1640170615196},"folder":{"id":"MsSQGFOv5","name":"Terminal commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"Wxm6Cdn2jZdwjGSz"}
{"name":"ООП в PHP","folderId":"ypLZomIFh","content":[{"label":"Fragment 1","language":"php","value":"Объектно-ориентированное программирование - методология программирования, основанная на представлении программы в виде совокупности объектов каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.\r\n\r\nИнкапсуляция      - это свойство системы, позволяющее объединить данные и методы в классе, и скрыть все детали реализации от пользователя.\r\nНаследование      - это расширение и повторное использование методов в новых классах, созданных на основе старых.\r\nПолимофрфизм      - это способность объектов с одним интерфейсом иметь несколько реализаций.\r\nКонструктор       - это специальный метод класса, который вызывается автоматически при инстанцинации объекта.\r\nСущность          - это объект, способный сохранять свое состояние (информацию) и обеспечивающий набор операций (поведение) для изменения этого состояния.\r\nАбстрактный класс - \r\nКласс             - набор свойств и методов, служащие шаблоном при его инстанцировании.\r\n    <?php\r\n    class Car{}\r\n    ?>\r\n\r\nОбъект            - это экземпляр класса, имеющий конкретное состояние и поведение, полностью определяемое классом.\r\n    <?php\r\n    class Car{}\r\n    $bmw = new Car();\r\n    ?>\r\n\r\nСвойство          - поле или переменная класса, принимающая значения.\r\n    <?php\r\n    class Car \r\n    {\r\n      // Свойства\r\n      public $color;\r\n    }\r\n    $bmw = new Car();\r\n    echo $bmw -> color = \"red\";\r\n    ?>\r\n\r\nМетод             - функция класса, для изменения состояния или поведения объекта.\r\n    <?php\r\n    class Car \r\n    {\r\n      // Свойства\r\n      public $color;\r\n      // Методы\r\n      function set_color($color) \r\n      {\r\n        $this->color = $color;\r\n      }\r\n    }\r\n    $bmw = new Car();\r\n    echo $bmw -> set_color(\"green\");\r\n    ?>\r\n\r\nИнтерфейс         - это набор методов класса, доступных для использования другими классами.\r\n\r\n\r\nСвойство или метод в классе можно объявить с одинм из трех уровней доступа - public, private, protected, static.\r\nДоступ к свойству или методу public можно получить из любого места вне класса. Значение можно изменить из любого участка вашего кода.\r\n    <?php\r\n    class Person\r\n    {\r\n      public $name;\r\n      public function getName()\r\n      {\r\n        return $this->name;\r\n      }\r\n    }\r\n    $person = new Person();\r\n    $person->name = 'Bob Smith';\r\n    echo $person->getName(); // prints 'Bob Smith'\r\n    ?>\r\n\r\nДоступ к свойству или методу private можно получить только из класса. Это означает, что нужно определить методы получения и установки, чтобы получить и установить значение этого свойства.\r\n    <?php\r\n    class Person\r\n    {\r\n      private $name;\r\n    \r\n      public function getName()\r\n      {\r\n        return $this->name;\r\n      }\r\n    \r\n      public function setName($name)\r\n      {\r\n        $this->name = $name;\r\n      }\r\n    }\r\n    \r\n    $person = new Person();\r\n    $person->name = 'Bob Smith'; // Throws an error\r\n    $person->setName('Bob Smith');\r\n    echo $person->getName(); // prints 'Bob Smith'\r\n    ?>\r\n\r\nДоступ к свойству или методу protected, может получить тот же класс, который их определил, или классы, которые наследуют рассматриваемый класс.\r\n    <?php\r\n    class Man\r\n    {\r\n      protected $name;\r\n\r\n      protected function setName($name)\r\n      {\r\n        $this->name = $name;\r\n      }\r\n      protected function getName()\r\n      {\r\n        return $this->name;\r\n      }\r\n    }\r\n    class Woman extends Man{}\r\n    \r\n    $woman = new Woman();\r\n    $woman->setName('Jill');\r\n    echo $woman->getName(); // prints 'Jill'\r\n    ?>\r\n\r\nStatic делает методы или свойства членами класса. Обращаться происходит с помощью конструкции двойного двоеточия имя_класса::имя_метода, не создавая новый объект. Доступ из объектов, к таким свойствам, будет не доступен.\r\n    <?php\r\n    class Man\r\n    {\r\n      public $name;\r\n\r\n      static function setName($name)\r\n      {\r\n        $this->name = $name;\r\n      }\r\n      static function getName()\r\n      {\r\n        return $this->name;\r\n      }\r\n    }\r\n    \r\n    Man::setName('Bob');\r\n    echo Man::getName(); // prints 'Bob'"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1639905470806},"updatedAt":{"$$date":1640690262727},"_id":"Xeb4tiKE51ZKfEKr","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Управление репозиториями","folderId":"ov1CCDtKz","content":[{"label":"Fragment 1","language":"powershell","value":"git init                                           # Создает новый проект в текущей директории.\r\ngit init путь_к_директории                         # Создает новый проект в указанной директории.\r\n\r\ngit clone адрес_репозитория                        # Клонирует удаленный репозиторий в текущую директорию.\r\ngit clone адрес_репозитория путь_к_директории      # Клонирует удаленный репозиторий в указанную директорию.\r\n\r\ngit remote -v                                      # Показывает список удалённых репозиториев, связанных с локальным.\r\ngit remote add origin url_репозитория              # Добавляет удалённый репозиторий с сокращенным именем origin, с указанным URL.\r\ngit remote rm origin                               # Удаляет привязку удалённого репозитория.\r\ngit remote show origin                             # Получает данные об удалённом репозитории с сокращенным именем origin.\r\n\r\ngit fetch origin                                   # Скачивает все ветки с удаленного репозитория с сокращенным именем origin, но не сливает со своими ветками.\r\ngit fetch origin имя_ветки                         # Скачивает указанную ветку, но не сливает ее с имеющейся.\r\n\r\ngit push origin имя_ветки                          # Отправляет в удалённый репозиторий с сокращенным именем origin указанную ветку.\r\ngit push -u origin имя_ветки                       # Отправляет в удалённый репозиторий с сокращенным именем origin указанную ветку, и делает ее отслеживаемой с указанной удаленной веткой.\r\ngit push origin :старое_имя_ветки новое_имя_ветки  # Переименовывает указанную старую ветку в удаленном репозитории.\r\n\r\ngit pull origin                                    # Вливает изменения со всех веток с удалённого репозитория.\r\ngit pull origin имя_ветки                          # Вливает изменения с указанной ветки с удалённого репозитория."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1639064986781},"updatedAt":{"$$date":1639328979564},"_id":"ZfMX09KlbHz3SN6R","folder":{"id":"ov1CCDtKz","name":"Git commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Права доступа","folderId":"MsSQGFOv5","content":[{"label":"Fragment 1","language":"powershell","value":"Категории пользователей:\r\nu - владелец; g - группа; o - прочие пользователи;\r\n\r\nАтрибуты определяющие доступ:\r\nr или 4 - Чтение, можно читать; w или 2 - Запись, можно редактировать; x или 0 - Выполнение, можно запускать на выполнение;\r\n\r\nПризнаки определяющие доступ:\r\ns - suid Любой пользователь может запустить файл на выполнение с правами его владельца; s - sgid Любой пользователь может запустить файл на выполнение с правами группы;\r\n\r\nwhoami                                       # Выводит список пользователей. Сокращение от Who am I.\r\n\r\ncat /etc/group                               # Выводит информацию о группах.\r\n\r\nsu                                           # Авторизация под пользователем root. Сокращение от Switch user.\r\nsu -                                         # Авторизация под пользователем root с использованием его переменных окружений.\r\nsu имя_пользователя                          # Авторизация под указанным пользователем.\r\nsu -l имя_пользователя                       # Авторизация под указанным пользователем с использованием его переменных окружений.\r\n\r\nsudo имя_команды                             # Выполняет указанную команду от имени root пользователя. Сокращение от Substitute User and do.\r\nsudo adduser имя_пользователя имя_группы     # Добавляет указанного пользователя в указанную группу.\r\n\r\nchown имя_владельца имя_файла                # Изменение валдельца для файла.\r\nchown имя_владельца имя_каталога             # Изменение валдельца для каталога.\r\nchown имя_владельца:имя_группы имя_файла     # Изменение валдельца и группы для файла.\r\nchown имя_владельца:имя_группы имя_каталога  # Изменение валдельца и группы для каталога.\r\n\r\nchgrp имя_группы имя_файла                   # Изменение группы для файла.\r\nchgrp имя_группы имя_каталога                # Изменение группы для каталога.\r\nchgrp -R имя_группы имя_каталога             # Рекурсиваное изменение группы для каталога.\r\nchgrp -R имя_группы имя_каталога             # Рекурсиваное изменение группы для каталога.\r\n\r\nchmod [ugo] [+-=] [rwx] имя_файла            # Изменение прав доступа к файлу.\r\nchmod [ugo] [+-=] [rwx] имя_каталога         # Изменение прав доступа к файлу.\r\nchmod 400 имя_файла_или_каталога             # Пользователь имеет право чтения. Никто другой не имеет права выполнять никакие действия.\r\nchmod 644 имя_файла_или_каталога             # Все пользователи имеют право чтения. Владец и группа могут редактировать.\r\nchmod 660 имя_файла_или_каталога             # Владелец и группа могут читать и редактировать. Остальные не имеют права выполнять никакие действия.\r\nchmod 700 имя_файла_или_каталога             # Владелец может читать, записывать и запускать на выполнение. Никто другой не имеет прва выполнять никакие действия.\r\nchmod 744 имя_файла_или_каталога             # Каждый пользователь может читать. Владелец имеет право редактировать и запускать на выполнение.\r\nchmod 755 имя_файла_или_каталога             # Каждый пользователь имеет право читать и запускать на выполнение. Пользователь может редактировать.\r\nchmod 777 имя_файла_или_каталога             # Каждый пользователь может читаь, редактировать и запускаь на выполнение.\r\nchmod числовой_атрибут -R имя_файла          # Рекурсивное изменения прав доступа к файлу.\r\nchmod числовой_атрибут -R имя_каталога       # Рекурсивное изменения прав доступа к каталогу."}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1639558976749},"updatedAt":{"$$date":1639758857117},"_id":"miWhOCpQU0JRmUQz","folder":{"id":"MsSQGFOv5","name":"Terminal commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"HTTP-клиент","folderId":"-2irHeXbe","content":[{"label":"Fragment 1","language":"php","value":"<?php\r\nnamespace Bloodmoorg;\r\n\r\nuse Bitrix\\Main\\Application;\r\nuse Bitrix\\Main\\Web\\HttpClient;\r\nuse Bitrix\\Main\\Web\\Json;\r\n\r\nclass BitrixWebClient \r\n{\r\n  /**\r\n    * Отправляет запросы \r\n    * @param string $url ссылка API\r\n    * @param array $data параметры запроса для GET запроса вида ['param_name' => 'value', ...] или тело запроса для PUT и POST\r\n    * @param string $method Метод GET, POST, PUT\r\n    * @return array|mixed\r\n    */\r\n  public static function sendRequest(string $url = '', array $params = [], string $method = 'GET') \r\n  {\r\n    if ($url == '') return ['error' => true, 'errorText' => 'Не указан url метода, запрос не отправлен (ошибка на стороне клиента)'];\r\n    \r\n    // Опции по умолчанию:\r\n    $options = array(\r\n        'redirect' => true, // true, если нужно выполнять редиректы\r\n        'redirectMax' => 5, // Максимальное количество редиректов\r\n        'waitResponse' => true, // true - ждать ответа, false - отключаться после запроса\r\n        'socketTimeout' => 30, // Таймаут соединения, сек\r\n        'streamTimeout' => 60, // Таймаут чтения ответа, сек, 0 - без таймаута\r\n        'streamTimeout' => HttpClient::HTTP_1_0, // версия HTTP (HttpClient::HTTP_1_0 или HttpClient::HTTP_1_1)\r\n        'streamTimeout' => '', // адрес\r\n        'proxyPort' => '', // порт\r\n        'proxyUser' => '', // имя\r\n        'proxyPassword' => '', // пароль\r\n        'compress' => false, // true - принимать gzip (Accept-Encoding: gzip)\r\n        'charset' => '', // Кодировка тела для POST и PUT\r\n        'disableSslVerification' => false, // true - отключить проверку ssl (с 15.5.9)\r\n    );\r\n    $httpClient = new HttpClient($options);\r\n\r\n    // Добавление загаловков\r\n    $httpClient->setHeader('Content-Type', 'application/json', true);\r\n    $httpClient->setHeader('name', 'value', true);\r\n\r\n    // Отправка запроса\r\n    switch ($method) \r\n    {\r\n      // Отправка методом GET. Параметры подставляются в URL \r\n      case 'GET':\r\n        $firstParamFlag = true;\r\n            foreach ($params as $key => $value) \r\n            {\r\n              $url .= ($firstParamFlag ? '?' : '&').$key.'='.$value;\r\n              $firstParamFlag = false;\r\n            }\r\n\r\n            $httpSend = $httpClient->query(HttpClient::HTTP_GET, $url);\r\n            if ($httpSend) \r\n            {\r\n              // Выбрать нужное\r\n              $response['RESULT'] = $httpClient->getResult(); // текст ответа\r\n              $response['STATUS'] = $httpClient->getStatus(); // код статуса ответа\r\n              $response['CONTENT_TYPE'] = $httpClient->getContentType(); // Content-Type ответа\r\n              $response['EFFECTIVE_URL'] = $httpClient->getEffectiveUrl(); // реальный url ответа, т.е. после редиректов\r\n              $response['COOKIES'] = $httpClient->getCookies(); // объект Bitrix\\Main\\Web\\HttpCookies\r\n              $response['HEADERS'] = $httpClient->getHeaders(); // объект Bitrix\\Main\\Web\\HttpHeaders\r\n              $response['ERROR'] = $httpClient->getError(); // массив ошибок\r\n              $response['FILE'] = $httpClient->download('http://example.ru/file.pdf', Application::getDocumentRoot() . '/upload/example/document.pdf');\r\n\r\n              return $response;\r\n            } \r\n            else \r\n            {\r\n              return ['error' => true, \"errorText\" => \"HTTP BX клиент не смог отправить запрос\"];\r\n            }\r\n            break\r\n      \r\n      // Отправка методом POST. Параметры подставляются в тело запроса\r\n      case 'POST':\r\n          $httpSend = $httpClient->query(HttpClient::HTTP_POST, $url, Json::encode($params));\r\n          if ($httpSend) \r\n          {\r\n            // Выбрать нужное\r\n            $response['RESULT'] = Json::decode($httpClient->getResult()); // текст ответа\r\n            $response['STATUS'] = $httpClient->getStatus(); // код статуса ответа\r\n            $response['CONTENT_TYPE'] = $httpClient->getContentType(); // Content-Type ответа\r\n            $response['EFFECTIVE_URL'] = $httpClient->getEffectiveUrl(); // реальный url ответа, т.е. после редиректов\r\n            $response['COOKIES'] = $httpClient->getCookies(); // объект Bitrix\\Main\\Web\\HttpCookies\r\n            $response['HEADERS'] = $httpClient->getHeaders(); // объект Bitrix\\Main\\Web\\HttpHeaders\r\n            $response['ERROR'] = $httpClient->getError(); // массив ошибок\r\n\r\n            return $response;\r\n          } \r\n          else \r\n          {\r\n            return ['error' => true, 'errorText' => 'HTTP BX клиент не смог отправить запрос'];\r\n          }\r\n          break;\r\n\r\n      // Отправка методом POST. Параметры подставляются в тело запроса\r\n      case 'PUT':\r\n          $httpSend = $httpClient->query(HttpClient::HTTP_PUT, $url, Json::encode($params));\r\n          if ($httpSend) \r\n          {\r\n            // Выбрать нужное\r\n            $response['RESULT'] = Json::decode($httpClient->getResult()); // текст ответа\r\n            $response['STATUS'] = $httpClient->getStatus(); // код статуса ответа\r\n            $response['CONTENT_TYPE'] = $httpClient->getContentType(); // Content-Type ответа\r\n            $response['EFFECTIVE_URL'] = $httpClient->getEffectiveUrl(); // реальный url ответа, т.е. после редиректов\r\n            $response['COOKIES'] = $httpClient->getCookies(); // объект Bitrix\\Main\\Web\\HttpCookies\r\n            $response['HEADERS'] = $httpClient->getHeaders(); // объект Bitrix\\Main\\Web\\HttpHeaders\r\n            $response['ERROR'] = $httpClient->getError(); // массив ошибок\r\n\r\n            return $response;\r\n          } \r\n          else \r\n          {\r\n            return ['error' => true, 'errorText' => 'HTTP BX клиент не смог отправить запрос'];\r\n          }\r\n          break;\r\n      }\r\n\r\n    return ['error' => true, 'errorText' => 'Что-то пошло не так: Неизвестная ошибка'];\r\n  }\r\n}\r\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1637132070568},"updatedAt":{"$$date":1639567959361},"_id":"uRoAIlNlmyfN4yNA","folder":{"id":"-2irHeXbe","name":"Bitrix","open":false,"defaultLanguage":"text","children":[]},"tagsPopulated":[]}
{"name":"Ветвление и состояние репозитория","folderId":"ov1CCDtKz","content":[{"label":"Fragment 1","language":"powershell","value":"git status                               # Показывает состояния репозитория.\r\n\r\ngit add .                                # Добавляет в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий.\r\ngit add имя_файла                        # Добавляет в индекс указанный изменненый, удаленный или новый файл.\r\ngit add -i                               # Запускает интерактивную оболочку для добавления в индекс только выбранных файлов.\r\n\r\ngit commit -m \"сообщение\"                # Коммитит проиндексированные изменения и добавляет сообщение.\r\ngit commit -c хеш_коммита                # Коммитит проиндексированные изменения, описание и информация об авторе берется из указанного коммита с редактированием.\r\ngit commit -С хеш_коммита                # Коммитит проиндексированные изменения, описание и информация об авторе берется из указанного коммита без редактирования.\r\ngit commit --amend -m \"сообщение\"        # Перемещает ветку на коммит назад, не обновляя рабочую директорию с индексом и на их основе создает новый коммит. Предыдущий коммит уходит из ветки. \r\n\r\ngit revert                               # Создает новый коммит, отменяющий изменения предыдущего коммита.\r\ngit revert хеш_коммита                   # Создает новый коммит, отменяющий изменения указанного коммита.\r\n\r\ngit branch                               # Показывает список веток.\r\ngit branch имя_ветки                     # Создает новую ветку с указанным именем на текущем коммите.\r\ngit branch -d имя_ветки                  # Удаляет ветку.\r\ngit branch -D имя_ветки                  # Принудительно удаляет ветку, с не сохранеными изменениями.\r\ngit branch -a                            # Показывает все имеющиеся ветки в т.ч. на удаленных репозиториях.\r\ngit branch -v                            # Показывает список веток и последний коммит в каждой.\r\ngit branch -m новое_имя_ветки            # Переименовывает текущую локальную ветку.\r\ngit branch -m имя_ветки новое_имя_ветки  # Переименовывает указанную старую ветку в локальном репозитории.\r\ngit branch -f имя_ветки хэш_коммита      # Перемещает ветку на указанный коммит, и создает ее, если ее нет.\r\ngit branch -f имя_ветки ORIG_HEAD        # Перемещает ветку на предыдущий коммит, после merge.\r\ngit branch --merged                      # Показывает ветки, уже слитые с активной.\r\ngit branch --no-merged                   # Показывает ветки, не слитые с активной.\r\n\r\ngit checkout                             # Перемещает указатель HEAD.\r\ngit checkout -f                          # Принудительно обновляет состояние рабочей директории из текущего коммита.\r\ngit checkout имя_ветки                   # Встает на указанную ветку.\r\ngit checkout имя_файла                   # Обновляет состояния файла в рабочую директорию из индекса.\r\ngit checkout -f имя_файла                # Принудительно обновляет состояние файла из текущего коммита.\r\ngit checkout -                           # Встает на предыдущую ветку.\r\ngit checkout -b имя_ветки                # Создает новую ветку с указанным именем и встает на неё.\r\ngit checkout -B имя_ветки хеш_коммита    # Создает новую ветку с указанным именем и встает на неё. Если такая ветка существует, то передвинет ее на указанный коммит.\r\ngit checkout хеш_коммита имя_файла       # Обновляет состояния файла из указанного коммита в рабочую директорию и индекс.\r\ngit checkout --ours                      # Выбрать изменения в ветке вкоторой находимся. Наши изменения.\r\ngit checkout --theirs                    # Выбрать изменения в сливаемой ветке. Другие изменения.\r\n\r\ngit stash                                # Сохраняет незакоммиченые изменения в файлах и очищает рабочую директорию. \r\ngit stash pop                            # Возвращает незакомиченные изменения. \r\n\r\ngit reset                                # Передвигает текущую ветку на текущий коммит и обновляет текущий индек из текущего коммита.\r\ngit reset хеш_коммита                    # Передвигает текущую ветку на указанный коммит и обновляет текущий индек из указанного коммита.\r\ngit reset --mixed                        # Передвигает текущую ветку на текущий коммит и обновляет текущий индек из текущего коммита.\r\ngit reset --mixed хеш_коммита            # Передвигает текущую ветку на указанный коммит и обновляет текущий индек из указанного коммита.\r\ngit reset --hard                         # Передвигает текущую ветку на текущий коммит и обновляет рабочую директорию вместе с индексом из текущего коммита.\r\ngit reset --hard хеш_коммита             # Передвигает текущую ветку на указанный коммит и обновляет рабочую директорию вместе с индексом из указанного коммита.\r\ngit reset --hard ORIG_HEAD               # Перемещает ветку на предыдущий коммит, после reset.\r\ngit reset --soft                         # Передвигает текущую ветку на текущий коммит и не обновляет рабочую директорию вместе с индексом из текущего коммита.\r\ngit reset --soft хеш_коммита             # Передвигает текущую ветку на указанный коммит и не обновляет рабочую директорию вместе с индексом из указанного коммита.\r\n\r\ngit clean -df                            # Удаляет неотслеживаемые файлы и директории.\r\ngit clean -xf                            # Удаляет файлы? которые игнориуются через gitignore.\r\n\r\ngit merge имя_ветки                      # Влить указанную ветку в текущую.\r\ngit merge --continue                     # Завершает слияние веток. Работает после разрешения конфликта слияния.\r\ngit merge --abort                        # Отменить слияние веток. Работает во время конфликта слияния.\r\ngit merge --squash имя_ветки             # Влить указанную ветку в текущую, без сохранения коммита слияния.\r\n\r\ngit cherry-pick хеш_коммита              # Копирует изменения из указанного коммита и создает новый в текущей ветке.\r\n"}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1638120221890},"updatedAt":{"$$date":1639413903258},"folder":{"id":"ov1CCDtKz","name":"Git commands","open":false,"defaultLanguage":"text"},"tagsPopulated":[],"_id":"vkzdnGOvJrsZcjBA"}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\n\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640785806462},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nЦ\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786040751},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\n\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786041340},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nW\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786042172},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786042616},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786044350},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb soc\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786044970},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786046113},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786047138},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это сетевой протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786048661},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это  протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786049283},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786215134},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол ghbr, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786215480},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол , позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786287518},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного , позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786288020},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - \r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786290780},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786291871},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - это протокол прикладного уровня прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786296011},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - это протокол прикладного уровня  передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786299446},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - это протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786304065},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - это протокол прикладного уровня прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786304700},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - протокол прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786320070},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - это протокол прикладного уровня прикладного уровня передачи файлов (Secure File Transfer Protocol), работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786320876},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP - это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786324757},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP (Secure File Transfer Protocol)- это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786341410},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов (File Transfer Protocol), для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP (Secure File Transfer Protocol) - это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786342169},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP - протокол передачи файлов , для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP (Secure File Transfer Protocol) - это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786343029},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP (File Transfer Protocol)- протокол передачи файлов , для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP (Secure File Transfer Protocol) - это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786346630},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста (Hyper Text Transfer Protocol Secure). Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP (File Transfer Protocol) - протокол передачи файлов , для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP (Secure File Transfer Protocol) - это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786347874},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS - это защищенный протокол передачи гипертекста . Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP (File Transfer Protocol) - протокол передачи файлов , для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP (Secure File Transfer Protocol) - это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786348696},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS (Hyper Text Transfer Protocol Secure) - это защищенный протокол передачи гипертекста . Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP (File Transfer Protocol) - протокол передачи файлов , для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP (Secure File Transfer Protocol) - это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786353079},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
{"name":"Web","folderId":"ypLZomIFh","content":[{"label":"Протокол HTTP","language":"powershell","value":"HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это сетевой протокол прикладного уровня, созданный поверх TCP прикладного уровня без сохранения состояния, используемый сервисом World Wide Web. HTTP предоставляет стандартные правила для взаимодействия веб-браузеров и серверов. По умолчанию данный протокол использует 80-ый порт.\r\n\r\nHTTP-запрос содержит стартовую строку, заголовки и тело обращения.\r\n\r\nСтруктура HTTP-запроса:\r\n  Стартовая строка содержит метод (GET, POST, PUT), адрес (URL), версию протокола HTTP (HTTP/1.1). \r\n    Пример:\r\n      # GET /wiki/index.html HTTP/1.1\r\n      # GET /index.php?month=august&date=24 HTTP/2.0\r\n  Заголовок содержит запись, состоящая из имени и значения, которая описывает того, кто обращается к серверу. \r\n    Пример:\r\n      # Host: ru.wikipedia.org\r\n      # Accept: text/html, application/xml\r\n  Тело обращения сожержит различные данные, если сам запрос подрузомевает их передачу.\r\n\r\nМетоды:\r\n  GET\t   # Используется для запроса содержимого указанного ресурса\r\n  HEAD\t # Применяется для извлечения метаданных, проверки наличия ресурса\r\n  PUT\t   # Применяется для загрузки содержимого запроса на указанный в запросе URI.\r\n  DELETE # Удаляет указанный ресурс\r\n  POST\t # Применяется для передачи пользовательских данных в теле запроса заданному ресурсу.\r\n  PATCH\t # Позволяет только создание или полную замену документа\r\n\r\nКоды ответа сервера:\r\n  200 ОК                    # Клиентский запрос успешен, и в ответе сервера содержатся запрошенные данные\r\n  403 Forbidden             #\tЗапрос отклонен (как правило этот ответ приходит, когда клиент не прошел аутентификацию)\r\n  404 Not Found             #\tДокумент с указанным URL не существует\r\n  500 Internal Server Error #\tКод указывает на возникновение аварийной ситуации на сервере\r\n\r\nЗаголовок            Группа  Описание\r\nAllow\t               Entity\t   # Список методов, применимых к запрашиваемому ресурсу.\r\nContent-Encoding\t   Entity\t   # Применяется при необходимости перекодировки содержимого (например, gzip/deflated).\r\nContent-Language\t   Entity\t   # Локализация содержимого (язык(и))\r\nContent-Length\t     Entity\t   # Размер тела сообщения (в октетах)\r\nContent-Range\t       Entity\t   # Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)\r\nContent-Type\t       Entity\t   # Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)\r\nExpires\t             Entity\t   # Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами\r\nLast-Modified\t       Entity\t   # Дата/время последней модификации сущности\r\nCache-Control\t       General   # Определяет директивы управления механизмами кэширования. Для прокси-серверов.\r\nConnection\t         General   # Задает параметры, требуемые для конкретного соединения.\r\nDate\t               General   # Дата и время формирования сообщения\r\nPragma\t             General   # Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache).\r\nTransfer-Encoding\t   General   # Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность.\r\nVia\t                 General   # Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером.\r\nWarning\t             General   # Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.\r\nAccept\t             Request   # Определяет применимые типы данных, ожидаемых в ответе.\r\nAccept-Charset\t     Request   # Определяет кодировку символов (charset) для данных, ожидаемых в ответе.\r\nAccept-Encoding\t     Request   # Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip)\r\nAccept-Language\t     Request   # Применимые языки. Используется для согласования передачи.\r\nAuthorization\t       Request   # Учетные данные клиента, запрашивающего ресурс.\r\nFrom\t               Request   # Электронный адрес отправителя\r\nHost\t               Request   # Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.\r\nIf-Modified-Since\t   Request   # Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.\r\nMax-Forwards\t       Request   # Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS.\r\nProxy-Authorization\t Request   # Используется при запросах, проходящих через прокси, требующие авторизации\r\nReferer\t             Request   # Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта.\r\nUser-Agent\t         Request   # Информация о пользовательском агенте (клиенте)\r\nLocation\t           Response  # Адрес перенаправления\r\nProxy-Authenticate\t Response  # Сообщение о статусе с кодом 407.\r\nServer\t             Response  # Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).\r\n\r\n\r\nHTTPS (Hyper Text Transfer Protocol Secure) - это защищенный протокол передачи гипертекста. Это продвинутая и безопасная версия HTTP. Для коммуникации данных используется 443-ий порт. Данный протокол позволяет обеспечить безопасность транзакций путем шифрования всего трафика с помощью SSL. Это комбинация протокола SSL/TLS и HTTP.\r\n\r\n\r\nFTP (File Transfer Protocol) - протокол передачи файлов , для управляющего соединения на сервере используется порт 21.\r\n  Пример:\r\n    ftp://user:pass@address:port/directory/file\r\n\r\n\r\nFTPS - расширение стандартного протокола передачи файлов, добавляющее в его базовый функционал создание шифрованных сессий с помощью протокола SSL (Secure Sockets Layer — уровень защищенных сокетов)\r\n\r\n\r\nSFTP (Secure File Transfer Protocol) - это протокол прикладного уровня прикладного уровня передачи файлов , работающий поверх безопасного канала. Если FTPS является просто расширением FTP, то SFTP это отдельный и никак не связанный с ним протокол, который в качестве основы использует SSH (Secure Shell – безопасная оболочка).\r\n  Пример:\r\n    sftp user:pass@address:port\r\n\r\n\r\nSSH – это протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).\r\n\r\nWeb socket - это протокол прикладного уровня\r\n\r\nМодель TCP/IP.\r\nTCP/IP - это целая сетевая модель, описывающая способ передачи данных в цифровом виде (Transmission Control Protocol и Internet Protocol). Сюда входит формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.\r\n\r\nУровни модели TCP/IP.\r\nКанальный (сетевой интерфейс) - аппаратный уровень обеспечивает взаимодействие сетевого оборудования Ethernet и Wi-Fi. Задача состоит в кодировании информации, ее делению на пакеты и отправке по нужному каналу. Также измеряются параметры сигнала вроде задержки ответа и расстояния между хостами.\r\n\r\nМежсетевой (Internet Layer) - маршрутизация осуществляется путем обращения к определенному IP-адресу с использованием маски. Если хосты находятся в одной подсети, маркируемой одной маской, данные передаются напрямую. В противном случае информация «путешествует» по целой цепочке промежуточных звеньев, пока не достигнет нужной точки. Назначение IP-адреса проводится по стандарту IPv4 или IPv6 (они не совместимы между собой).\r\n\r\nТранспортный уровень (Transport Layer) - отвечает за контроль доставки, чтобы не возникало дублей пакетов данных. В случае обнаружения потерь или ошибок информация запрашивается повторно. TCP дает возможность полностью автоматизировать процессы независимо от скорости и качества связи между отдельными участками интернета или внутри конкретной подсети.\r\n\r\nПрикладной уровень (Application Layer) - на него ложатся задачи по поддержанию сеанса связи, преобразованию данных, взаимодействию с пользователем и сетью. На этом уровне применяются стандарты интерфейса API, позволяющего передавать команды на выполнение определенных задач. Например, для открытия сайтов используется HTTPS, при отправке электронной почты – SMTP, для назначения IP-адресов – DHCP. Такой подход упрощает программирование, снижает нагрузку на сеть, увеличивает скорость обработки команд и передачи данных.\r\n\r\nСокет - комбинация IP-адреса и порта, используется при идентификации компьютера. Если первый критерий уникален для каждого хоста, второй обычно фиксирован для определенного типа приложений. Так, получение электронной почты проходит через 110 порт, передача данных по протоколу FTP – по 21, открытие сайтов – по 80.\r\n\r\nПреобразование IP-адресов в символьные адреса активно используется для назначения буквенно-цифровых названий веб-ресурсов. При вводе домена в адресной строке браузера сначала происходит обращение к специальному серверу DNS. Он всегда прослушивает порт 53 у всех компьютеров, которые подключены к интернету, и по запросу преобразует введенное название в стандартный IP-адрес. После определения точного местонахождения файлов сайта включается обычная схема работы – от прикладного уровня с кодированием данных до обращения к физическому оборудованию на уровне сетевых интерфейсов. Процесс называется инкапсуляцией информации. На принимающей стороне происходит обратная процедура – декапсуляция."},{"label":"Fragment 2","language":null,"value":null}],"tags":[],"isFavorites":false,"isDeleted":false,"createdAt":{"$$date":1640071975564},"updatedAt":{"$$date":1640786354335},"_id":"WtP67H4xxiYSJnf7","folder":{"id":"ypLZomIFh","name":"База знаний","open":false,"defaultLanguage":"text"},"tagsPopulated":[]}
